# main.py
import os, math, json, time, random, logging
from threading import Thread
from datetime import datetime, timezone, timedelta
from typing import Tuple

import ccxt
import pandas as pd
import numpy as np
import pytz
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters
from telegram.error import Conflict

# ================== LOGGING ==================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
)
log = logging.getLogger("bot")

# ================== ENV & DEFAULTS ==================
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
TZ                 = os.getenv("TZ", "Asia/Ho_Chi_Minh")
TIMEFRAME_DEFAULT  = os.getenv("TIMEFRAME", "15m")

AUTO_SCAN          = os.getenv("AUTO_SCAN", "true").lower() == "true"
SCAN_INTERVAL_SEC  = int(os.getenv("SCAN_INTERVAL_SEC", "3600"))
ALERT_THRESHOLD    = int(os.getenv("ALERT_THRESHOLD", "80"))
MIN_VOLZ           = float(os.getenv("MIN_VOLZ", "2"))

MARKET_TYPE        = os.getenv("MARKET_TYPE", "swap")
QUOTE              = os.getenv("QUOTE", "USDT").upper()

LABEL_TP_PCT       = float(os.getenv("LABEL_TP_PCT", "0.004"))
LABEL_SL_PCT       = float(os.getenv("LABEL_SL_PCT", "0.004"))

CHAT_ID            = int(os.getenv("CHAT_ID", "7992112548"))

DATA_DIR = "/data"
os.makedirs(DATA_DIR, exist_ok=True)

MEMO_PATH    = os.path.join(DATA_DIR, "memory.json")
PENDING_PATH = os.path.join(DATA_DIR, "pending.json")
TRADES_PATH  = os.path.join(DATA_DIR, "trades.json")

if not os.path.exists(MEMO_PATH):
    with open(MEMO_PATH, "w", encoding="utf-8") as f:
        json.dump({"w":[0,0,0,0,0,0], "lr":0.03}, f)

if not os.path.exists(TRADES_PATH):
    with open(TRADES_PATH, "w", encoding="utf-8") as f:
        json.dump([], f)

if not os.path.exists(PENDING_PATH):
    with open(PENDING_PATH, "w", encoding="utf-8") as f:
        json.dump({}, f)


# ================== KEEP ALIVE ==================
def start_keep_alive():
    try:
        from keep_alive import run_server
        Thread(target=run_server, daemon=True).start()
        print("‚úÖ keep_alive started", flush=True)
    except Exception as e:
        print("‚ö†Ô∏è keep_alive failed:", repr(e), flush=True)

# ================== Helpers ==================
VALID_TF = {"1m","3m","5m","15m","30m","1h","2h","4h","6h","12h","1d"}

def parse_symbol_tf(text: str, default_tf: str) -> Tuple[str, str]:
    parts = (text or "").strip().lower().split()
    if not parts:
        raise ValueError("B·∫°n ch∆∞a nh·∫≠p coin.")
    base = parts[0].upper()
    tf = default_tf
    if len(parts) > 1 and parts[1].lower() in VALID_TF:
        tf = parts[1].lower()
    return base, tf

def fmt(x, nd=6):
    try:
        return f"{float(x):.{nd}f}"
    except Exception:
        return str(x)
def cooldown_ok(symbol: str, side: str) -> bool:
    key = f"{symbol}_{side}"
    now = time.time()
    last = LAST_SIGNAL_TIME.get(key, 0)
    return (now - last) > COOLDOWN_MINUTES * 60

        
def in_trading_hours(
    start_hour: int = 8,
    end_hour: int = 22,
    tz_name: str = "Asia/Ho_Chi_Minh"
) -> bool:
    """
    Ki·ªÉm tra c√≥ ƒëang trong gi·ªù trade hay kh√¥ng
    M·∫∑c ƒë·ªãnh: 08:00 -> 22:00 gi·ªù VN
    """
    try:
        import pytz
        tz = pytz.timezone(tz_name)
        now = datetime.now(tz)
    except Exception:
        now = datetime.now()

    hour = now.hour
    return start_hour <= hour < end_hour


# ================== CCXT (MEXC Swap) ==================
EX = ccxt.mexc({
    "options": {"defaultType": MARKET_TYPE},
    "enableRateLimit": True,
})

def symbol_usdt_perp(base: str) -> str:
    return f"{base.upper()}/{QUOTE}:{QUOTE}"

# ================== Indicators ==================
def ema(s, n): 
    return s.ewm(span=n, adjust=False).mean()
    
def get_htf_trend(base: str) -> str:
    """
    X√°c ƒë·ªãnh xu h∆∞·ªõng khung 1H ƒë·ªÉ l·ªçc trade 15m
    UP    -> ch·ªâ ƒë∆∞·ª£c LONG
    DOWN  -> ch·ªâ ƒë∆∞·ª£c SHORT
    SIDE  -> b·ªè qua
    """
    df_htf = fetch_ohlcv(base, "1h", limit=300)

    # EMA50 & EMA200 chu·∫©n
    df_htf["ema50"] = ema(df_htf["close"], 50)
    df_htf["ema200"] = ema(df_htf["close"], 200)

    df_htf = df_htf.dropna()
    if len(df_htf) < 5:
        return "SIDE"

    ema50 = df_htf["ema50"].iloc[-1]
    ema200 = df_htf["ema200"].iloc[-1]

    if ema50 > ema200:
        return "UP"
    elif ema50 < ema200:
        return "DOWN"
    else:
        return "SIDE"

def rsi(close, n=14):
    d = close.diff()
    up, down = d.clip(lower=0), (-d).clip(lower=0)
    rs = up.rolling(n).mean() / (down.rolling(n).mean() + 1e-9)
    return 100 - (100 / (1 + rs))

def macd(close, fast=12, slow=26, signal=9):
    f, s = ema(close, fast), ema(close, slow)
    m = f - s
    sig = ema(m, signal)
    h = m - sig
    return m, sig, h

def atr(df, n=14):
    h, l, c = df["high"], df["low"], df["close"]
    pc = c.shift(1)
    tr = pd.concat([(h - l), (h - pc).abs(), (l - pc).abs()], axis=1).max(axis=1)
    return tr.rolling(n).mean()

# ================== Market Structure ==================
def detect_bos(df: pd.DataFrame, lookback: int = 20) -> str:
    high = df["high"]
    low = df["low"]

    swing_high = high.rolling(lookback).max()
    swing_low = low.rolling(lookback).min()

    last_close = df["close"].iloc[-1]

    if last_close > swing_high.iloc[-2]:
        return "BOS_UP"
    if last_close < swing_low.iloc[-2]:
        return "BOS_DOWN"
    return "NO_BOS"

def break_retest_ok(df: pd.DataFrame, side: str, lookback: int = 20, tol: float = 0.002) -> bool:
    high = df["high"]
    low = df["low"]

    swing_high = high.rolling(lookback).max()
    swing_low = low.rolling(lookback).min()

    last_close = df["close"].iloc[-1]

    if side == "LONG":
        level = swing_high.iloc[-2]
        return abs(last_close - level) / level <= tol

    if side == "SHORT":
        level = swing_low.iloc[-2]
        return abs(last_close - level) / level <= tol

    return False

def detect_strong_bos(df: pd.DataFrame, lookback: int = 20) -> str:
    """
    BOS m·∫°nh cho futures:
    - Close ph√° swing
    - Body n·∫øn l·ªõn (>=60%)
    - Volume tƒÉng
    """
    if len(df) < lookback + 2:
        return "NO_BOS"

    high = df["high"]
    low = df["low"]

    swing_high = high.rolling(lookback).max()
    swing_low = low.rolling(lookback).min()

    last = df.iloc[-1]

    o = last["open"]
    h = last["high"]
    l = last["low"]
    c = last["close"]

    body = abs(c - o)
    range_ = h - l
    if range_ == 0:
        return "NO_BOS"

    body_ratio = body / range_

    vol = last["volume"]
    vol_ma = df["volume"].rolling(20).mean().iloc[-2]

    # BOS UP
    if (
        c > swing_high.iloc[-2] and
        body_ratio >= 0.6 and
        vol > vol_ma and
        c > o
    ):
        return "BOS_UP"

    # BOS DOWN
    if (
        c < swing_low.iloc[-2] and
        body_ratio >= 0.6 and
        vol > vol_ma and
        c < o
    ):
        return "BOS_DOWN"

    return "NO_BOS"


# ================== Candlestick patterns ==================
def detect_pattern(df: pd.DataFrame) -> str:
    last = df.iloc[-1]
    prev = df.iloc[-2]
    o, h, l, c = float(last["open"]), float(last["high"]), float(last["low"]), float(last["close"])
    op, cp = float(prev["open"]), float(prev["close"])

    rng = h - l
    if rng <= 0:
        return "-"

    body = abs(c - o)

    if body < rng * 0.3 and c > o:
        return "Hammer üü¢"
    if body < rng * 0.3 and c < o:
        return "Inverted Hammer üî¥"
    if c > op and o < cp and (c - o) > rng * 0.5:
        return "Bullish Engulfing üíö"
    if c < op and o > cp and (o - c) > rng * 0.5:
        return "Bearish Engulfing ‚ù§Ô∏è"
    if body < rng * 0.05:
        return "Doji ‚ö™"
    return "-"

# ================== Data ==================
def fetch_ohlcv(base: str, tf: str, limit: int = 300) -> pd.DataFrame:
    sym = symbol_usdt_perp(base)
    try:
        data = EX.fetch_ohlcv(sym, timeframe=tf, limit=limit)
    except Exception:
        sym2 = f"{base.upper()}/{QUOTE}"
        data = EX.fetch_ohlcv(sym2, timeframe=tf, limit=limit)

    df = pd.DataFrame(data, columns=["ts","open","high","low","close","volume"])
    df["ts"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
    return df

def enrich(df: pd.DataFrame) -> pd.DataFrame:
    d = df.copy()

    d["ema12"] = ema(d["close"], 12)
    d["ema26"] = ema(d["close"], 26)

    m, s, h = macd(d["close"])
    d["macd"], d["macd_sig"], d["macd_hist"] = m, s, h

    d["rsi"] = rsi(d["close"])
    d["atr"] = atr(d)

    v = d["volume"]
    d["vol_z"] = (v - v.rolling(50).mean()) / (v.rolling(50).std() + 1e-9)

    d["pattern"] = "-"
    if len(d) > 2:
        d.loc[d.index[-1], "pattern"] = detect_pattern(d)

    d = d.dropna()
    if len(d) < 5:
        raise ValueError("Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch.")
    return d

# ================== Online AI ==================
class OnlineAI:
    def __init__(self, path: str):
        self.path = path
        self.w = np.zeros(6, dtype=float)
        self.lr = 0.03
        self._load()

    def _load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    obj = json.load(f)
                self.w = np.array(obj.get("w", self.w.tolist()), dtype=float)
                self.lr = float(obj.get("lr", self.lr))
            except Exception:
                pass

    def _save(self):
        obj = {}
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    obj = json.load(f)
            except Exception:
                obj = {}
        obj["w"] = self.w.tolist()
        obj["lr"] = float(self.lr)
        with open(self.path, "w", encoding="utf-8") as f:
            json.dump(obj, f, indent=2, ensure_ascii=False)

    def _feat(self, row: dict) -> np.ndarray:
        trend = (row["ema12"] - row["ema26"]) / (abs(row["ema26"]) + 1e-9)
        macd_h = float(row["macd_hist"])
        rsi_c = (float(row["rsi"]) - 50.0) / 50.0
        volz = float(np.tanh(float(row["vol_z"]) / 3.0))
        atrp = float(row["atr"]) / max(float(row["close"]), 1e-9)
        bias = 1.0
        return np.array([trend, macd_h, rsi_c, volz, atrp, bias], dtype=float)

    def _sigmoid(self, z: float) -> float:
        if z >= 0:
            ez = math.exp(-z)
            return 1.0 / (1.0 + ez)
        ez = math.exp(z)
        return ez / (1.0 + ez)

    def score(self, row: dict) -> int:
        x = self._feat(row)
        z = float(np.dot(self.w, x))
        p = self._sigmoid(z)
        return int(round(p * 100))

    def learn(self, row: dict, label: int):
        x = self._feat(row)
        z = float(np.dot(self.w, x))
        p = self._sigmoid(z)
        grad = (p - label) * x
        self.w -= self.lr * grad
        self._save()

AI = OnlineAI(MEMO_PATH)

# ================== Analysis ==================
def make_targets(entry: float, atrv: float, side: str):
    tp1 = entry + (1.5 * atrv if side == "LONG" else -1.5 * atrv)
    tp2 = entry + (2.5 * atrv if side == "LONG" else -2.5 * atrv)
    sl  = entry - (1.0 * atrv if side == "LONG" else -1.0 * atrv)
    return tp1, tp2, sl

def analyze(base: str, tf: str) -> dict:
    # ===== TIME FILTER (08h-22h VN) =====
    if not in_trading_hours(8, 22, TZ):
        return {"skip": True, "reason": "Out of trading hours (08-22)"}
        
    df = enrich(fetch_ohlcv(base, tf, limit=300))
    row = df.iloc[-1].to_dict()
    # ===== ATR FILTER =====
    atr_ratio = row["atr"] / row["close"]

    if atr_ratio < 0.002:
        return {"skip": True, "reason": "ATR too low"}
    
    #  HTF trend filter (1H)
    htf_trend = get_htf_trend(base)
    if htf_trend == "SIDE":
        return {"skip": True, "reason": "HTF sideways"}

    # ===== STRONG BOS (15m) =====
    bos = detect_strong_bos(df)
    if bos == "NO_BOS":
        return {"skip": True, "reason": "Weak / fake BOS"}

    # X√°c ƒë·ªãnh h∆∞·ªõng trade
    side = "LONG" if bos == "BOS_UP" else "SHORT"

    # ===== COOLDOWN =====
    if not cooldown_ok(base, side):
        return {"skip": True, "reason": "Cooldown"}

    # ===== BREAK & RETEST =====
    if not break_retest_ok(df, side):
        return {"skip": True, "reason": "No break & retest"}


    # ===== HTF DIRECTION LOCK =====
    if htf_trend == "UP" and side != "LONG":
        return {"skip": True, "reason": "HTF UP only LONG"}

    if htf_trend == "DOWN" and side != "SHORT":
        return {"skip": True, "reason": "HTF DOWN only SHORT"}

    # ===== VOLUME CONFIRM =====
    if abs(row["vol_z"]) < MIN_VOLZ:
        return {"skip": True, "reason": "Weak volume"}
    # ===== RSI FILTER =====
    rsi_val = row["rsi"]

    if side == "LONG" and not (45 <= rsi_val <= 65):
        return {"skip": True, "reason": "RSI not good LONG"}

    if side == "SHORT" and not (35 <= rsi_val <= 55):
        return {"skip": True, "reason": "RSI not good SHORT"}


    # ===== AI SCORE =====
    score = AI.score(row)
    
    # 3. TP / SL theo ATR
    entry = float(row["close"])
    atrv = float(row["atr"])
    tp = entry + (2.0 * atrv if side == "LONG" else -2.0 * atrv)
    sl = entry - (1.0 * atrv if side == "LONG" else -1.0 * atrv)

    # 4. L∆∞u trade ƒë·ªÉ theo d√µi WIN / LOSE
    trade = {
        "time": datetime.utcnow().isoformat(),
        "base": base,
        "tf": tf,
        "side": side,
        "entry": entry,
        "tp": tp,
        "sl": sl,
        "features": AI._feat(row).tolist(),
        "status": "OPEN"
    }

    with open(TRADES_PATH, "r+", encoding="utf-8") as f:
        trades = json.load(f)
        trades.append(trade)
        f.seek(0)
        json.dump(trades, f, indent=2)
    LAST_SIGNAL_TIME[f"{base}_{side}"] = time.time()

    return {
        "base": base.upper(),
        "tf": tf,
        "side": side,
        "price": entry,
        "tp": tp,
        "sl": sl,
        "score": score,
        "bos": bos
    }
def update_trades_and_learn():
    with open(TRADES_PATH, "r+", encoding="utf-8") as f:
        trades = json.load(f)

    changed = False

    for t in trades:
        if t["status"] != "OPEN":
            continue

        df = fetch_ohlcv(t["base"], t["tf"], limit=5)
        high = df["high"].iloc[-1]
        low = df["low"].iloc[-1]

        row = {
            "ema12": 1.0 + t["features"][0],
            "ema26": 1.0,
            "macd_hist": t["features"][1],
            "rsi": 50.0 + t["features"][2] * 50.0,
            "vol_z": t["features"][3],
            "atr": max(t["features"][4], 1e-6),
            "close": 1.0
        }


        if t["side"] == "LONG":
            if high >= t["tp"]:
                t["status"] = "WIN"
                AI.learn(row, 1)
                changed = True
            elif low <= t["sl"]:
                t["status"] = "LOSE"
                AI.learn(row, 0)
                changed = True

        if t["side"] == "SHORT":
            if low <= t["tp"]:
                t["status"] = "WIN"
                AI.learn(row, 1)
                changed = True
            elif high >= t["sl"]:
                t["status"] = "LOSE"
                AI.learn(row, 0)
                changed = True

    if changed:
        with open(TRADES_PATH, "w", encoding="utf-8") as f:
            json.dump(trades, f, indent=2)

# ================== Telegram ==================
async def cmd_start(update, ctx):
    await update.message.reply_text(
        "ü§ñ Bot AI Futures ƒë√£ s·∫µn s√†ng!\n"
        "‚Ä¢ G√µ coin: btc ho·∫∑c sol 15m\n"
        "‚Ä¢ Bot t·ª± ƒë·ªông g·ª≠i t√≠n hi·ªáu m·ªói 1h khi c√≥ s√≥ng m·∫°nh\n"
    )

async def handle_text(update, ctx):
    text = (update.message.text or "").strip()
    try:
        update_trades_and_learn()
        base, tf = parse_symbol_tf(text, TIMEFRAME_DEFAULT)
        r = analyze(base, tf)

        if r.get("skip"):
            await update.message.reply_text(f"‚è≠Ô∏è B·ªè qua: {r['reason']}")
            return

        msg = (
            f"üìä {r['base']} ({r['tf']})\n"
            f"H∆∞·ªõng: {r['side']} | BOS: {r['bos']}\n"
            f"Entry: {fmt(r['price'])}\n"
            f"TP: {fmt(r['tp'])} | SL: {fmt(r['sl'])}\n"
            f"AI Score: {r['score']}%"
        )
        await update.message.reply_text(msg)

    except Exception as e:
        await update.message.reply_text(f"‚ö†Ô∏è L·ªói ph√¢n t√≠ch: {e}")


# ================== Auto scan ==================
async def auto_scan(ctx):
    # ===== TIME FILTER (08h-22h VN) =====
    if not in_trading_hours(8, 22, TZ):
        return
    chat_id = int(ctx.job.data["chat_id"])
    update_trades_and_learn()
    top = ["BTC","ETH","SOL","WLD","XRP","TON","ARB","LINK","PEPE","SUI"]

    for coin in top:
        try:
            r = analyze(coin, TIMEFRAME_DEFAULT)

            if r.get("skip"):
                continue

            if r["score"] >= ALERT_THRESHOLD:
                msg = (
                    f"üî• T√≠n hi·ªáu m·∫°nh ‚Äî {r['base']}/USDT ({r['tf']})\n"
                    f"H∆∞·ªõng: {r['side']} | BOS: {r['bos']}\n"
                    f"Entry: {fmt(r['price'])}\n"
                    f"TP: {fmt(r['tp'])} | SL: {fmt(r['sl'])}\n"
                    f"AI Score: {r['score']}%"
                )

                await ctx.application.bot.send_message(
                    chat_id=chat_id,
                    text=msg
                )

        except Exception as e:
            log.warning("scan fail %s: %r", coin, e)

# ================== Drive Sync (t·ª± t·∫Øt n·∫øu invalid_grant) ==================
import io, threading
from googleapiclient.discovery import build
from google.oauth2.credentials import Credentials
from googleapiclient.http import MediaFileUpload, MediaIoBaseDownload

_drive_enabled = True  # s·∫Ω t·∫Øt n·∫øu invalid_grant

def _has_drive_env() -> bool:
    return all([
        os.getenv("GOOGLE_REFRESH_TOKEN"),
        os.getenv("GOOGLE_CLIENT_ID"),
        os.getenv("GOOGLE_CLIENT_SECRET"),
    ])

def google_creds():
    return Credentials(
        None,
        refresh_token=os.getenv("GOOGLE_REFRESH_TOKEN"),
        token_uri="https://oauth2.googleapis.com/token",
        client_id=os.getenv("GOOGLE_CLIENT_ID"),
        client_secret=os.getenv("GOOGLE_CLIENT_SECRET"),
        scopes=[
            "https://www.googleapis.com/auth/drive.file",
            "https://www.googleapis.com/auth/drive.metadata.readonly",
        ],
    )

def _is_invalid_grant(err: Exception) -> bool:
    s = repr(err).lower()
    return "invalid_grant" in s or "bad request" in s

def sync_ai_memory_to_drive():
    global _drive_enabled
    if not _drive_enabled:
        return
    try:
        if not os.path.exists(MEMO_PATH):
            return

        with open(MEMO_PATH, "r", encoding="utf-8") as f:
            memory_data = json.load(f)

        memory_data["_last_synced_utc"] = datetime.now(timezone.utc).isoformat()

        with open("AI_memory.json", "w", encoding="utf-8") as f:
            json.dump(memory_data, f, indent=2, ensure_ascii=False)

        creds = google_creds()
        service = build("drive", "v3", credentials=creds)

        media = MediaFileUpload("AI_memory.json", mimetype="application/json")
        resp = service.files().list(q="name='AI_memory.json'", spaces="drive").execute()

        if resp.get("files"):
            file_id = resp["files"][0]["id"]
            service.files().update(fileId=file_id, media_body=media).execute()
        else:
            meta = {"name": "AI_memory.json"}
            service.files().create(body=meta, media_body=media, fields="id").execute()

    except Exception as e:
        if _is_invalid_grant(e):
            _drive_enabled = False
            print("‚õî Google Drive invalid_grant -> T·∫ÆT sync Drive (c·∫ßn c·∫•p l·∫°i refresh token).", flush=True)
        else:
            print("‚ö†Ô∏è Drive Sync Error:", repr(e), flush=True)

def load_ai_memory_from_drive():
    global _drive_enabled
    if not _drive_enabled:
        return None
    try:
        creds = google_creds()
        service = build("drive", "v3", credentials=creds)
        results = service.files().list(q="name='AI_memory.json'", spaces="drive").execute()
        files = results.get("files", [])
        if not files:
            return None

        file_id = files[0]["id"]
        request = service.files().get_media(fileId=file_id)
        fh = io.BytesIO()
        downloader = MediaIoBaseDownload(fh, request)
        done = False
        while not done:
            _, done = downloader.next_chunk()

        fh.seek(0)
        data = json.load(fh)

        with open(MEMO_PATH, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        if "w" in data:
            AI.w = np.array(data["w"], dtype=float)

        print("‚úÖ ƒê√£ t·∫£i AI_memory.json t·ª´ Drive.", flush=True)
        return data

    except Exception as e:
        if _is_invalid_grant(e):
            _drive_enabled = False
            print("‚õî Google Drive invalid_grant -> T·∫ÆT sync Drive (c·∫ßn c·∫•p l·∫°i refresh token).", flush=True)
        else:
            print("‚ö†Ô∏è L·ªói khi t·∫£i AI_memory.json:", repr(e), flush=True)
        return None

def auto_backup_loop(interval_hours=3):
    def loop():
        while True:
            try:
                sync_ai_memory_to_drive()
                if _drive_enabled:
                    print(f"üïí Drive sync ({datetime.now().strftime('%H:%M:%S')})", flush=True)
            except Exception as e:
                print("‚ö†Ô∏è L·ªói auto backup:", repr(e), flush=True)
            time.sleep(interval_hours * 3600)
    threading.Thread(target=loop, daemon=True).start()

# ================== Run ==================
def _seconds_to_next_hour(tz_name: str) -> int:
    try:
        import pytz
        tz = pytz.timezone(tz_name)
        now = datetime.now(tz)
    except Exception:
        now = datetime.now()

    nxt = (now + timedelta(hours=1)).replace(minute=0, second=5, microsecond=0)
    delta = int((nxt - now).total_seconds())
    return max(10, delta)

async def post_init(app):
    # d·ªçn webhook/pending tr∆∞·ªõc khi polling
    await app.bot.delete_webhook(drop_pending_updates=True)
    me = await app.bot.get_me()
    print(f"‚úÖ Telegram OK: @{me.username} (id={me.id})", flush=True)

async def on_error(update, ctx):
    err = ctx.error
    if isinstance(err, Conflict):
        print("‚ö†Ô∏è Conflict: c√≥ instance kh√°c ƒëang polling token n√†y.", flush=True)
    else:
        print("‚ö†Ô∏è Error:", repr(err), flush=True)

def main():
    start_keep_alive()

    print("AUTO_SCAN =", AUTO_SCAN)

    if not TELEGRAM_BOT_TOKEN:
        raise RuntimeError("Thi·∫øu TELEGRAM_BOT_TOKEN trong Environment Variables.")

    if _has_drive_env():
        load_ai_memory_from_drive()
        auto_backup_loop(3)
    else:
        print("‚ÑπÔ∏è Thi·∫øu Google Drive ENV -> b·ªè qua sync.", flush=True)

    # retry loop ƒë·ªÉ kh√¥ng ch·∫øt v√¨ Conflict (Render restart/deploy ch·ªìng)
    while True:
        try:
            app = (
                ApplicationBuilder()
                .token(TELEGRAM_BOT_TOKEN)
                .post_init(post_init)
                .build()
            )

            app.add_handler(CommandHandler("start", cmd_start))
            app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
            app.add_error_handler(on_error)

            if AUTO_SCAN:
                first = _seconds_to_next_hour(TZ)
                app.job_queue.run_repeating(
                    auto_scan,
                    interval=SCAN_INTERVAL_SEC,
                    first=first,
                    data={"chat_id": CHAT_ID},
                )

            print("ü§ñ Bot polling start...", flush=True)
            app.run_polling(drop_pending_updates=True, allowed_updates=None)
            break

        except Conflict:
            wait = 20 + random.randint(0, 20)
            print(f"‚ö†Ô∏è Conflict getUpdates -> ƒë·ª£i {wait}s r·ªìi ch·∫°y l·∫°i...", flush=True)
            time.sleep(wait)

if __name__ == "__main__":
    main()
